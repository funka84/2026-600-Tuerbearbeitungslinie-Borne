<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="fb_CoeDataRead" Id="{4ea307d5-b019-4e0e-b383-ffad8b6ef0ff}" SpecialFunc="None">
    <Declaration><![CDATA[(*======================================================================================================================================*)
(*	Dieser Baustein Liest die vorher an I_stParameter definierten Parameter über COE aus  (ACHTUNG NUR LESEN)  *)
(*
Date          	| Version    	| created under        	| Author          	| Remark *)
(*======================================================================================================================================*)
(*02/04/2024   	| 1.00      		| TC2		  		| N.Kersting       | first release *)
(*03/04/2024   	| 1.01     		| TC2		  		| N.Kersting       | Neuen Autotimer hinzugefügt, um Zyklisch auszulesen  *)
(*03/04/2024   	| 1.02     		| TC2		  		| N.Kersting       | Neuen Autoquittierung für Fehler hinzugefügt   *)
(*02/10/2024   	| 1.03     		| TC2		  		| N.Kersting       | Neue Zugriffoption 4 = Überspringen  *)
(*======================================================================================================================================*)
FUNCTION_BLOCK fb_CoeDataRead
VAR_INPUT
	I_bExecute		:BOOL;
	I_tAutoTime		:TIME :=t#2s;
	I_sNetID			:STRING;
	I_nSlave			:UINT;
	I_stParameter		:ARRAY[0..GVL_1000.MaxCOEParam] OF st_COE_Parameter;
END_VAR
VAR_OUTPUT
	Q_stParameter	:ARRAY[0..GVL_1000.MaxCOEParam] OF st_COE_Parameter_Out;
	Q_bBusy			:BOOL;
	Q_bError			:BOOL;
END_VAR
VAR
	nRead			:DWORD;
	tonAutoTimer		:TON;
	tonQuitTimer		:TON;
	iParam			:INT;
	iStepCoE		:INT;
	fbCoERead		:FB_EcCoESdoRead;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[tonAutoTimer(PT:=I_tAutoTime );
tonQuitTimer(PT:=t#10s );

CASE iStepCoE OF

0:	Q_bBusy			:=	FALSE;
	tonAutoTimer.IN	:=	FALSE;
	tonQuitTimer.IN	:=	FALSE;
	nRead			:=	0;

	iParam		:= 0;

	IF I_bExecute
	THEN
		iStepCoE := 1;
		Q_bError := FALSE;
	END_IF

1:	Q_bBusy 		:= 	TRUE;
	nRead			:=	0;

	fbCoERead(
		sNetId:=	I_sNetID ,
		nSlaveAddr:= 	I_nSlave,
		bExecute:=		FALSE );

	iStepCoE := iStepCoE+1;

2:	IF iParam <= GVL_1000.MaxCOEParam
	THEN
		iStepCoE := iStepCoE+1;
	ELSE
		iStepCoE := 999;	(*ENDE*)
	END_IF

3:	IF	I_stParameter[iParam].nZugriff	= 0
		OR I_stParameter[iParam].nZugriff	= 2
	THEN

		fbCoERead(
			nSubIndex:= 	I_stParameter[iParam].nSubIndex,
			nIndex:=		I_stParameter[iParam].nIndex ,
			pDstBuf:= 	ADR(nRead),
			cbBufLen:= 	SIZEOF(nRead),
			bExecute:= 	TRUE,
			tTimeout:= 	t#10s );

		IF	fbCoERead.bBusy
			AND NOT fbCoERead.bError
		THEN
			iStepCoE := iStepCoE+1;
		ELSIF
			fbCoERead.bError
		THEN
			iStepCoE := -99; (*ERROR*)
		END_IF
	ELSIF
		I_stParameter[iParam].nZugriff = 3
	THEN
		fbCoERead(
			bExecute:= 	FALSE );

		iStepCoE := 5;
	ELSIF
		I_stParameter[iParam].nZugriff = 4
	THEN
		fbCoERead(
			bExecute:= 	FALSE );

		iStepCoE := 5;
	END_IF

4:	fbCoERead(
			bExecute:= 	FALSE );

	IF NOT fbCoERead.bBusy
		AND NOT  fbCoERead.bError
	THEN
		IF I_stParameter[iParam].nFaktor > 0
		THEN
			Q_stParameter[iParam].nWert		:=	DWORD_TO_LREAL(nRead)*I_stParameter[iParam].nFaktor;
			Q_stParameter[iParam].sName		:=	I_stParameter[iParam].sName;
			iStepCoE := iStepCoE+1;
		END_IF
	ELSIF
		 fbCoERead.bError
	THEN
		iStepCoE :=- 99;
	END_IF

5:	IF I_stParameter[iParam].nZugriff	= 3
	THEN
		iStepCoE := 999;	(*ENDE*)
	ELSE
		iStepCoE :=iStepCoE +1;
	END_IF

6:	iParam	:= iParam+1;
	iStepCoE :=1;

999:	(*ENDE *)
	Q_bBusy			:= 	FALSE;
	tonAutoTimer.IN	:=	TRUE;

	IF NOT	I_bExecute
		OR (tonAutoTimer.Q
		AND I_bExecute)
	THEN
		iParam	:= 0;
		iStepCoE :=	0;
	END_IF

-99:	(*ERROR*)
	Q_bError		 := TRUE;
	Q_bBusy		:= FALSE;
	tonQuitTimer.IN	:=	TRUE;


	IF NOT	I_bExecute
		OR (tonQuitTimer.Q
		AND I_bExecute)
	THEN
		iStepCoE :=	0;
	END_IF

END_CASE]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>